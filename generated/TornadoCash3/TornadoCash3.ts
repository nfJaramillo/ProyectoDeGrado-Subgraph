// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class TornadoCash3Deposit extends ethereum.Event {
  get params(): TornadoCash3Deposit__Params {
    return new TornadoCash3Deposit__Params(this);
  }
}

export class TornadoCash3Deposit__Params {
  _event: TornadoCash3Deposit;

  constructor(event: TornadoCash3Deposit) {
    this._event = event;
  }

  get commitment(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get leafIndex(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class TornadoCash3Withdrawal extends ethereum.Event {
  get params(): TornadoCash3Withdrawal__Params {
    return new TornadoCash3Withdrawal__Params(this);
  }
}

export class TornadoCash3Withdrawal__Params {
  _event: TornadoCash3Withdrawal;

  constructor(event: TornadoCash3Withdrawal) {
    this._event = event;
  }

  get to(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nullifierHash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get relayer(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get fee(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class TornadoCash3 extends ethereum.SmartContract {
  static bind(address: Address): TornadoCash3 {
    return new TornadoCash3("TornadoCash3", address);
  }

  nullifierHashes(param0: Bytes): boolean {
    let result = super.call(
      "nullifierHashes",
      "nullifierHashes(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBoolean();
  }

  try_nullifierHashes(param0: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "nullifierHashes",
      "nullifierHashes(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  verifier(): Address {
    let result = super.call("verifier", "verifier():(address)", []);

    return result[0].toAddress();
  }

  try_verifier(): ethereum.CallResult<Address> {
    let result = super.tryCall("verifier", "verifier():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  hashLeftRight(_left: Bytes, _right: Bytes): Bytes {
    let result = super.call(
      "hashLeftRight",
      "hashLeftRight(bytes32,bytes32):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(_left),
        ethereum.Value.fromFixedBytes(_right)
      ]
    );

    return result[0].toBytes();
  }

  try_hashLeftRight(_left: Bytes, _right: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "hashLeftRight",
      "hashLeftRight(bytes32,bytes32):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(_left),
        ethereum.Value.fromFixedBytes(_right)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  FIELD_SIZE(): BigInt {
    let result = super.call("FIELD_SIZE", "FIELD_SIZE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_FIELD_SIZE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("FIELD_SIZE", "FIELD_SIZE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  levels(): BigInt {
    let result = super.call("levels", "levels():(uint32)", []);

    return result[0].toBigInt();
  }

  try_levels(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("levels", "levels():(uint32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  operator(): Address {
    let result = super.call("operator", "operator():(address)", []);

    return result[0].toAddress();
  }

  try_operator(): ethereum.CallResult<Address> {
    let result = super.tryCall("operator", "operator():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isKnownRoot(_root: Bytes): boolean {
    let result = super.call("isKnownRoot", "isKnownRoot(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(_root)
    ]);

    return result[0].toBoolean();
  }

  try_isKnownRoot(_root: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall("isKnownRoot", "isKnownRoot(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(_root)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  commitments(param0: Bytes): boolean {
    let result = super.call("commitments", "commitments(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);

    return result[0].toBoolean();
  }

  try_commitments(param0: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall("commitments", "commitments(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  denomination(): BigInt {
    let result = super.call("denomination", "denomination():(uint256)", []);

    return result[0].toBigInt();
  }

  try_denomination(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("denomination", "denomination():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  currentRootIndex(): BigInt {
    let result = super.call(
      "currentRootIndex",
      "currentRootIndex():(uint32)",
      []
    );

    return result[0].toBigInt();
  }

  try_currentRootIndex(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "currentRootIndex",
      "currentRootIndex():(uint32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isSpentArray(_nullifierHashes: Array<Bytes>): Array<boolean> {
    let result = super.call(
      "isSpentArray",
      "isSpentArray(bytes32[]):(bool[])",
      [ethereum.Value.fromFixedBytesArray(_nullifierHashes)]
    );

    return result[0].toBooleanArray();
  }

  try_isSpentArray(
    _nullifierHashes: Array<Bytes>
  ): ethereum.CallResult<Array<boolean>> {
    let result = super.tryCall(
      "isSpentArray",
      "isSpentArray(bytes32[]):(bool[])",
      [ethereum.Value.fromFixedBytesArray(_nullifierHashes)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBooleanArray());
  }

  getLastRoot(): Bytes {
    let result = super.call("getLastRoot", "getLastRoot():(bytes32)", []);

    return result[0].toBytes();
  }

  try_getLastRoot(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("getLastRoot", "getLastRoot():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  roots(param0: BigInt): Bytes {
    let result = super.call("roots", "roots(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBytes();
  }

  try_roots(param0: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall("roots", "roots(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  ROOT_HISTORY_SIZE(): BigInt {
    let result = super.call(
      "ROOT_HISTORY_SIZE",
      "ROOT_HISTORY_SIZE():(uint32)",
      []
    );

    return result[0].toBigInt();
  }

  try_ROOT_HISTORY_SIZE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "ROOT_HISTORY_SIZE",
      "ROOT_HISTORY_SIZE():(uint32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isSpent(_nullifierHash: Bytes): boolean {
    let result = super.call("isSpent", "isSpent(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(_nullifierHash)
    ]);

    return result[0].toBoolean();
  }

  try_isSpent(_nullifierHash: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall("isSpent", "isSpent(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(_nullifierHash)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  zeros(param0: BigInt): Bytes {
    let result = super.call("zeros", "zeros(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBytes();
  }

  try_zeros(param0: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall("zeros", "zeros(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  ZERO_VALUE(): BigInt {
    let result = super.call("ZERO_VALUE", "ZERO_VALUE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_ZERO_VALUE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("ZERO_VALUE", "ZERO_VALUE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  filledSubtrees(param0: BigInt): Bytes {
    let result = super.call(
      "filledSubtrees",
      "filledSubtrees(uint256):(bytes32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBytes();
  }

  try_filledSubtrees(param0: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "filledSubtrees",
      "filledSubtrees(uint256):(bytes32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  nextIndex(): BigInt {
    let result = super.call("nextIndex", "nextIndex():(uint32)", []);

    return result[0].toBigInt();
  }

  try_nextIndex(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nextIndex", "nextIndex():(uint32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ChangeOperatorCall extends ethereum.Call {
  get inputs(): ChangeOperatorCall__Inputs {
    return new ChangeOperatorCall__Inputs(this);
  }

  get outputs(): ChangeOperatorCall__Outputs {
    return new ChangeOperatorCall__Outputs(this);
  }
}

export class ChangeOperatorCall__Inputs {
  _call: ChangeOperatorCall;

  constructor(call: ChangeOperatorCall) {
    this._call = call;
  }

  get _newOperator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ChangeOperatorCall__Outputs {
  _call: ChangeOperatorCall;

  constructor(call: ChangeOperatorCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get _proof(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _root(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _nullifierHash(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get _recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _relayer(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get _fee(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get _refund(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class UpdateVerifierCall extends ethereum.Call {
  get inputs(): UpdateVerifierCall__Inputs {
    return new UpdateVerifierCall__Inputs(this);
  }

  get outputs(): UpdateVerifierCall__Outputs {
    return new UpdateVerifierCall__Outputs(this);
  }
}

export class UpdateVerifierCall__Inputs {
  _call: UpdateVerifierCall;

  constructor(call: UpdateVerifierCall) {
    this._call = call;
  }

  get _newVerifier(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateVerifierCall__Outputs {
  _call: UpdateVerifierCall;

  constructor(call: UpdateVerifierCall) {
    this._call = call;
  }
}

export class DepositCall extends ethereum.Call {
  get inputs(): DepositCall__Inputs {
    return new DepositCall__Inputs(this);
  }

  get outputs(): DepositCall__Outputs {
    return new DepositCall__Outputs(this);
  }
}

export class DepositCall__Inputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get _commitment(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class DepositCall__Outputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _verifier(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _denomination(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _merkleTreeHeight(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _operator(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}
